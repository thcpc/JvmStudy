# DataType 设计思路
## 字节码中读取长度单位
在读取字节码时，字节码的读取单位分别为
- u1 无符号整数 1 字节 0-255
- u2 无符号整数 2 字节 0-65535
- u4 无符号整数 4 字节 0-4294967295

## Java 中 有符号整数的类型,最高位为符号位
- short 有符号整数 2 字节 -32768 - (32768-1)
- int 有符号整数 4 字节 -2147483648 - (2147483648-1)
- long 有符号整数 8 字节 -9223372036854776000 - (9223372036854776000-1)

因此根据取值范围
- short 存放读取长度 u1 单位的值
- int 存放读取长度 u2 单位的值
- long 存放读取长度 u4 单位的值

## 实现
1. 读取对应长度单位的字节
```java
# u1 length=1, u2 length=2 ,u4 length=4
byte[] bytes = new byte[length];
inputstream.read(bytes)
```
2. 去除符号位，并保存值
```java
short number = 0;
for(abyte:bytes){
    number <<=8; 
    number |= (abyte & 0xFF)
}
```

### 相关步骤的知识点

```java
short number = 0;
```
一个short 是2个字节 <br />
初始化 00000000 00000000 <br />
```java
number <<=8
```
<<为左移操作,低位补0，
开始的时候<br /> 

00000000 0000000<font color="#dd0000">0</font><br />
移动8位后<br />
0000000<font color="#dd0000">0</font> <font color="#666600">00000000</font><br />
浅黄色的0就是移动后补位的0
这样就保证了，与 abyte 操作的始终00000000
```java
number |= (abyte & 0xFF)
```
以 CA 为例 <br />
CA 的2进制: 11001010 <br />
10进制: 202 <br />
Byte: -54, 原因如下<br />
1. 在计算机中，所有的数字都是以补码表示的，而非原码，因为计算机只有加数寄存器
- 正数 补码 = 原码
- 负数 补码 = 反码 + 1；反码 = 符号位不变，其余位取反<br />
比如+1 和 -1 在计算机存储的<br />

+1 补码 = 0000 0001 所以 计算机中存储 0000 0001<br />
-1 补码 = 1111 1111 所以 计算机中存储 1111 1111<br />

+1 + -1 = 0, 则是两个补码相加 最高位为1，溢出，剩下的为0<br />
2. CA 在计算机存储的 11001010 为补码非原码<br />
因为最高位为1<br />
原码 = (补码符号位不变，其他位取反 + 1)<br />
原码 = 10110101 + 1 = 10110110 = -54

3. 当byte 强制转化为 short 时，高位会强制补1 <br />
1100 1010 => 1111 1111 1100 1010<br />
原码 = 1000 0000 0011 0101 + 1 = 1000 0000 0011 0110 = -54 此时存储值错误<br />
0xFF = 0000 0000 1111 1111<br />
abyte & 0xFF = (1111 1111 1100 1010) & (0000 0000 1111 1111) = 0000 0000 1100 1010<br />
number |= (abyte & 0xFF) = 0000000<font color="#dd0000">0</font> <font color="#666600">00000000</font> | 0000 0000 1100 1010<br />
number = 0000 0000 1100 1010

此时， short number = 202

